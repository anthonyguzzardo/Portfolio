---
/**
 * ThemeBackground.astro
 * WebGL background component that renders the current theme's shader
 * Uses Three.js for GPU-accelerated rendering
 */

interface Props {
  class?: string;
  opacity?: number;
}

const { class: className = '', opacity = 1.0 } = Astro.props;
---

<canvas
  id="theme-background"
  class:list={['theme-background', className]}
  data-opacity={opacity}
></canvas>

<style>
  .theme-background {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    pointer-events: none;
  }
</style>

<script>
  import * as THREE from 'three';
  import { getTheme, initializeTheme } from '../themes';
  import type { Theme } from '../themes/types';

  class ThemeBackgroundRenderer {
    private canvas: HTMLCanvasElement;
    private renderer: THREE.WebGLRenderer;
    private scene: THREE.Scene;
    private camera: THREE.OrthographicCamera;
    private material: THREE.ShaderMaterial | null = null;
    private mesh: THREE.Mesh | null = null;
    private clock: THREE.Clock;
    private animationId: number = 0;
    private currentTheme: Theme | null = null;
    private baseOpacity: number;

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.baseOpacity = parseFloat(canvas.dataset.opacity || '1.0');
      this.clock = new THREE.Clock();

      // Scene setup
      this.scene = new THREE.Scene();
      this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      // Renderer setup
      this.renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: false,
        alpha: true,
        powerPreference: 'high-performance',
      });
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      this.renderer.setSize(window.innerWidth, window.innerHeight);

      // Initialize with current theme
      const theme = initializeTheme();
      this.loadTheme(theme);

      // Start animation
      this.animate();

      // Event listeners
      this.setupEventListeners();
    }

    private loadTheme(theme: Theme): void {
      this.currentTheme = theme;

      // Clean up existing mesh
      if (this.mesh) {
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        if (this.material) {
          this.material.dispose();
        }
      }

      // Check if theme has shaders
      if (!theme.shaders) {
        // No shader, just use solid color background
        this.renderer.setClearColor(theme.colors.background, 1);
        this.mesh = null;
        this.material = null;
        return;
      }

      // Create shader material
      this.material = new THREE.ShaderMaterial({
        vertexShader: theme.shaders.vertex,
        fragmentShader: theme.shaders.fragment,
        uniforms: {
          u_time: { value: 0 },
          u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          u_opacity: { value: this.baseOpacity },
        },
        transparent: true,
        depthWrite: false,
      });

      // Full-screen quad
      const geometry = new THREE.PlaneGeometry(2, 2);
      this.mesh = new THREE.Mesh(geometry, this.material);
      this.scene.add(this.mesh);
    }

    private animate = (): void => {
      if (this.material) {
        this.material.uniforms.u_time.value = this.clock.getElapsedTime();
      }

      this.renderer.render(this.scene, this.camera);
      this.animationId = requestAnimationFrame(this.animate);
    };

    private onResize = (): void => {
      const width = window.innerWidth;
      const height = window.innerHeight;

      this.renderer.setSize(width, height);

      if (this.material) {
        this.material.uniforms.u_resolution.value.set(width, height);
      }
    };

    private onThemeChange = (event: CustomEvent<{ themeId: string }>): void => {
      const theme = getTheme(event.detail.themeId);
      if (theme) {
        this.loadTheme(theme);
      }
    };

    private setupEventListeners(): void {
      window.addEventListener('resize', this.onResize);
      window.addEventListener('theme:change', this.onThemeChange as EventListener);

      // Cleanup on page navigation (Astro)
      document.addEventListener('astro:before-swap', this.dispose);
    }

    private dispose = (): void => {
      cancelAnimationFrame(this.animationId);

      if (this.mesh) {
        this.mesh.geometry.dispose();
      }
      if (this.material) {
        this.material.dispose();
      }
      this.renderer.dispose();

      window.removeEventListener('resize', this.onResize);
      window.removeEventListener('theme:change', this.onThemeChange as EventListener);
      document.removeEventListener('astro:before-swap', this.dispose);
    };
  }

  // Initialize when DOM is ready
  function init(): void {
    const canvas = document.getElementById('theme-background') as HTMLCanvasElement;
    if (canvas) {
      new ThemeBackgroundRenderer(canvas);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
