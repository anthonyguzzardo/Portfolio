---
/**
 * ThemeBackground.astro
 * WebGL background component that renders the current theme's shader
 * Uses Three.js for GPU-accelerated rendering
 */

interface Props {
  class?: string;
  opacity?: number;
}

const { class: className = '', opacity = 1.0 } = Astro.props;
---

<canvas
  id="theme-background"
  class:list={['theme-background', className]}
  data-opacity={opacity}
></canvas>

<!-- Tile Size Slider (shown for liquid-glass theme) -->
<div id="tile-slider-container" class="tile-slider-container hidden">
  <div class="liquid-glass-pill">
    <label for="tile-slider">Size</label>
    <input
      type="range"
      id="tile-slider"
      min="0.1"
      max="200"
      value="60"
      step="0.1"
    />
    <span id="tile-value">60</span>
  </div>
</div>

<!-- Fibers Theme GUI Panel -->
<div id="fibers-gui-container" class="fibers-gui-container hidden">
  <div class="fibers-gui-panel">
    <div class="gui-section">
      <h4>Fiber</h4>
      <div class="gui-row">
        <label>Scale</label>
        <input type="range" data-uniform="u_scale" min="0.05" max="2.0" value="1.0" step="0.05" />
        <span class="gui-value">1.0</span>
      </div>
      <div class="gui-row">
        <label>Radius</label>
        <input type="range" data-uniform="u_radius" min="0.005" max="0.05" value="0.018" step="0.001" />
        <span class="gui-value">0.018</span>
      </div>
      <div class="gui-row">
        <label>Sharpness</label>
        <input type="range" data-uniform="u_sharpness" min="1" max="20" value="8" step="0.5" />
        <span class="gui-value">8</span>
      </div>
      <div class="gui-row">
        <label>Length</label>
        <input type="range" data-uniform="u_length" min="0.2" max="1.5" value="0.8" step="0.05" />
        <span class="gui-value">0.8</span>
      </div>
      <div class="gui-row">
        <label>Texture</label>
        <input type="range" data-uniform="u_texture" min="0" max="1" value="0.3" step="0.05" />
        <span class="gui-value">0.3</span>
      </div>
      <div class="gui-row">
        <label>Angle</label>
        <input type="range" data-uniform="u_angle" min="-90" max="90" value="15" step="1" />
        <span class="gui-value">15째</span>
      </div>
      <div class="gui-row">
        <label>Curve</label>
        <input type="range" data-uniform="u_curve" min="0" max="0.02" value="0.003" step="0.001" />
        <span class="gui-value">0.003</span>
      </div>
      <div class="gui-row">
        <label>Bend</label>
        <input type="range" data-uniform="u_bend" min="-5" max="5" value="0" step="0.1" />
        <span class="gui-value">0</span>
      </div>
      <div class="gui-row">
        <label>Kink</label>
        <input type="range" data-uniform="u_kink" min="0" max="3" value="0" step="0.1" />
        <span class="gui-value">0</span>
      </div>
    </div>
    <div class="gui-section">
      <h4>Lighting</h4>
      <div class="gui-row">
        <label>Light Angle</label>
        <input type="range" data-uniform="u_lightAngle" min="0" max="360" value="45" step="1" />
        <span class="gui-value">45째</span>
      </div>
      <div class="gui-row">
        <label>Light Height</label>
        <input type="range" data-uniform="u_lightHeight" min="0" max="1" value="0.5" step="0.05" />
        <span class="gui-value">0.5</span>
      </div>
      <div class="gui-row">
        <label>Specular</label>
        <input type="range" data-uniform="u_specular" min="0" max="1" value="0.4" step="0.05" />
        <span class="gui-value">0.4</span>
      </div>
      <div class="gui-row">
        <label>Glossiness</label>
        <input type="range" data-uniform="u_glossiness" min="4" max="128" value="32" step="4" />
        <span class="gui-value">32</span>
      </div>
    </div>
    <div class="gui-section gui-actions">
      <button id="fibers-reset-btn" class="gui-reset-btn">Reset</button>
    </div>
  </div>
</div>

<style>
  .theme-background {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    pointer-events: none;
  }

  .theme-background.interactive {
    pointer-events: auto;
    cursor: grab;
  }

  .theme-background.interactive.dragging {
    cursor: grabbing;
  }

  /* Tile Slider */
  .tile-slider-container {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
    pointer-events: auto;
  }

  .tile-slider-container.hidden {
    display: none;
  }

  .liquid-glass-pill {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 20px;
    border-radius: 999px;
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-shadow:
      0 8px 32px rgba(0, 0, 0, 0.3),
      inset 0 1px 0 rgba(255, 255, 255, 0.1),
      inset 0 -1px 0 rgba(0, 0, 0, 0.1);
  }

  .liquid-glass-pill label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 12px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .liquid-glass-pill input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 150px;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }

  .liquid-glass-pill input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    transition: transform 0.15s ease;
  }

  .liquid-glass-pill input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.15);
  }

  .liquid-glass-pill input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  }

  .liquid-glass-pill #tile-value {
    color: white;
    font-size: 14px;
    font-weight: 600;
    min-width: 32px;
    text-align: right;
    font-variant-numeric: tabular-nums;
  }

  /* Fibers GUI Panel */
  .fibers-gui-container {
    position: fixed;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    pointer-events: auto;
  }

  .fibers-gui-container.hidden {
    display: none;
  }

  .fibers-gui-panel {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    gap: 32px;
    padding: 20px 28px;
    border-radius: 16px;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  }

  .gui-section {
    min-width: 260px;
  }

  .gui-section.gui-actions {
    min-width: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    padding-top: 24px;
  }

  .gui-section h4 {
    color: rgba(255, 255, 255, 0.5);
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin: 0 0 12px 0;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .gui-row {
    display: grid;
    grid-template-columns: 90px 1fr 55px;
    align-items: center;
    gap: 12px;
    margin-bottom: 10px;
  }

  .gui-row label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 13px;
    font-weight: 500;
  }

  .gui-row input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    background: rgba(255, 255, 255, 0.15);
    border-radius: 3px;
    outline: none;
    cursor: pointer;
  }

  .gui-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    transition: transform 0.1s ease;
  }

  .gui-row input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.15);
  }

  .gui-row input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  }

  .gui-value {
    color: rgba(255, 255, 255, 0.9);
    font-size: 13px;
    font-weight: 500;
    text-align: right;
    font-variant-numeric: tabular-nums;
  }

  .gui-reset-btn {
    padding: 10px 24px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.8);
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .gui-reset-btn:hover {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 255, 255, 0.3);
    color: white;
  }

  .gui-reset-btn:active {
    transform: scale(0.97);
  }
</style>

<script>
  import * as THREE from 'three';
  import { getTheme, initializeTheme } from '../themes';
  import type { Theme } from '../themes/types';

  class ThemeBackgroundRenderer {
    private canvas: HTMLCanvasElement;
    private renderer: THREE.WebGLRenderer;
    private scene: THREE.Scene;
    private camera: THREE.OrthographicCamera;
    private material: THREE.ShaderMaterial | null = null;
    private mesh: THREE.Mesh | null = null;
    private clock: THREE.Clock;
    private animationId: number = 0;
    private currentTheme: Theme | null = null;
    private baseOpacity: number;

    // Mouse interaction state
    private isInteractive: boolean = false;
    private hasMouseTracking: boolean = false;
    private isDragging: boolean = false;
    private lastMouse: { x: number; y: number } = { x: 0, y: 0 };
    private rotation: { x: number; y: number } = { x: 0, y: 0 };
    private velocity: { x: number; y: number } = { x: 0, y: 0 };
    private readonly DAMPING = 0.95;
    private readonly SENSITIVITY = 0.005;

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.baseOpacity = parseFloat(canvas.dataset.opacity || '1.0');
      this.clock = new THREE.Clock();

      // Scene setup
      this.scene = new THREE.Scene();
      this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      // Renderer setup
      this.renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: false,
        alpha: true,
        powerPreference: 'high-performance',
      });
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      this.renderer.setSize(window.innerWidth, window.innerHeight);

      // Initialize with current theme
      const theme = initializeTheme();
      this.loadTheme(theme);

      // Start animation
      this.animate();

      // Event listeners
      this.setupEventListeners();
    }

    private loadTheme(theme: Theme): void {
      this.currentTheme = theme;

      // Clean up existing mesh
      if (this.mesh) {
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        if (this.material) {
          this.material.dispose();
        }
      }

      // Check if theme has shaders
      if (!theme.shaders) {
        // No shader, just use solid color background
        this.renderer.setClearColor(theme.colors.background, 1);
        this.mesh = null;
        this.material = null;
        return;
      }

      // Build uniforms object
      const uniforms: { [key: string]: { value: unknown } } = {
        u_time: { value: 0 },
        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        u_opacity: { value: this.baseOpacity },
      };

      // Add custom uniforms from theme
      if (theme.shaders.uniforms) {
        for (const [key, uniform] of Object.entries(theme.shaders.uniforms)) {
          if (key === 'u_time' || key === 'u_resolution' || key === 'u_opacity') continue;
          if (uniform.type === 'float') {
            uniforms[key] = { value: uniform.value };
          } else if (uniform.type === 'vec2') {
            const v = uniform.value as number[];
            uniforms[key] = { value: new THREE.Vector2(v[0], v[1]) };
          }
        }
      }

      // Check if theme supports rotation (interactive)
      this.isInteractive = !!(theme.shaders.uniforms && 'u_rotation' in theme.shaders.uniforms);
      if (this.isInteractive) {
        uniforms.u_rotation = { value: new THREE.Vector2(0, 0) };
        this.canvas.classList.add('interactive');
        // Reset rotation state for new theme
        this.rotation = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
      } else {
        this.canvas.classList.remove('interactive');
      }

      // Check if theme supports mouse tracking (u_mouse uniform)
      this.hasMouseTracking = !!(theme.shaders.uniforms && 'u_mouse' in theme.shaders.uniforms);

      // Show/hide tile slider based on theme
      const sliderContainer = document.getElementById('tile-slider-container');
      if (sliderContainer) {
        if (theme.shaders.uniforms && 'u_tileSize' in theme.shaders.uniforms) {
          sliderContainer.classList.remove('hidden');
        } else {
          sliderContainer.classList.add('hidden');
        }
      }

      // Show/hide fibers GUI based on theme
      const fibersGuiContainer = document.getElementById('fibers-gui-container');
      if (fibersGuiContainer) {
        if (theme.shaders.uniforms && 'u_radius' in theme.shaders.uniforms) {
          fibersGuiContainer.classList.remove('hidden');
          // Sync slider values with theme defaults
          this.syncFibersGuiValues(theme);
        } else {
          fibersGuiContainer.classList.add('hidden');
        }
      }

      // Create shader material
      this.material = new THREE.ShaderMaterial({
        vertexShader: theme.shaders.vertex,
        fragmentShader: theme.shaders.fragment,
        uniforms,
        transparent: true,
        depthWrite: false,
      });

      // Full-screen quad
      const geometry = new THREE.PlaneGeometry(2, 2);
      this.mesh = new THREE.Mesh(geometry, this.material);
      this.scene.add(this.mesh);
    }

    private animate = (): void => {
      if (this.material) {
        this.material.uniforms.u_time.value = this.clock.getElapsedTime();

        // Update rotation with momentum
        if (this.isInteractive && this.material.uniforms.u_rotation) {
          if (!this.isDragging) {
            // Apply velocity when not dragging
            this.rotation.x += this.velocity.x;
            this.rotation.y += this.velocity.y;
            // Apply damping
            this.velocity.x *= this.DAMPING;
            this.velocity.y *= this.DAMPING;
          }
          // Update uniform
          (this.material.uniforms.u_rotation.value as THREE.Vector2).set(
            this.rotation.x,
            this.rotation.y
          );
        }
      }

      this.renderer.render(this.scene, this.camera);
      this.animationId = requestAnimationFrame(this.animate);
    };

    private onResize = (): void => {
      const width = window.innerWidth;
      const height = window.innerHeight;

      this.renderer.setSize(width, height);

      if (this.material) {
        this.material.uniforms.u_resolution.value.set(width, height);
      }
    };

    private onThemeChange = (event: CustomEvent<{ themeId: string }>): void => {
      const theme = getTheme(event.detail.themeId);
      if (theme) {
        this.loadTheme(theme);
      }
    };

    // Mouse handlers for interactive rotation
    private onMouseDown = (e: MouseEvent): void => {
      if (!this.isInteractive) return;
      this.isDragging = true;
      this.lastMouse = { x: e.clientX, y: e.clientY };
      this.canvas.classList.add('dragging');
    };

    private onMouseMove = (e: MouseEvent): void => {
      // Update u_mouse uniform for mouse tracking themes
      if (this.hasMouseTracking && this.material && this.material.uniforms.u_mouse) {
        // Convert to shader coordinates (y-flipped)
        (this.material.uniforms.u_mouse.value as THREE.Vector2).set(
          e.clientX,
          window.innerHeight - e.clientY
        );
      }

      // Handle interactive rotation (dragging)
      if (!this.isDragging || !this.isInteractive) return;

      const deltaX = e.clientX - this.lastMouse.x;
      const deltaY = e.clientY - this.lastMouse.y;

      // Update rotation (horizontal drag = Y rotation, vertical drag = X rotation)
      this.rotation.x -= deltaX * this.SENSITIVITY; // Inverted for natural feel
      this.rotation.y += deltaY * this.SENSITIVITY;

      // Store velocity for momentum
      this.velocity.x = -deltaX * this.SENSITIVITY;
      this.velocity.y = deltaY * this.SENSITIVITY;

      this.lastMouse = { x: e.clientX, y: e.clientY };
    };

    private onMouseUp = (): void => {
      if (!this.isInteractive) return;
      this.isDragging = false;
      this.canvas.classList.remove('dragging');
    };

    // Touch handlers for mobile
    private onTouchStart = (e: TouchEvent): void => {
      if (!this.isInteractive || e.touches.length !== 1) return;
      this.isDragging = true;
      this.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      this.canvas.classList.add('dragging');
    };

    private onTouchMove = (e: TouchEvent): void => {
      if (!this.isDragging || !this.isInteractive || e.touches.length !== 1) return;

      const deltaX = e.touches[0].clientX - this.lastMouse.x;
      const deltaY = e.touches[0].clientY - this.lastMouse.y;

      this.rotation.x -= deltaX * this.SENSITIVITY;
      this.rotation.y += deltaY * this.SENSITIVITY;

      this.velocity.x = -deltaX * this.SENSITIVITY;
      this.velocity.y = deltaY * this.SENSITIVITY;

      this.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    };

    private onTouchEnd = (): void => {
      if (!this.isInteractive) return;
      this.isDragging = false;
      this.canvas.classList.remove('dragging');
    };

    private onTileSizeChange = (e: Event): void => {
      const slider = e.target as HTMLInputElement;
      const value = parseFloat(slider.value);

      // Update uniform
      if (this.material && this.material.uniforms.u_tileSize) {
        this.material.uniforms.u_tileSize.value = value;
      }

      // Update display value
      const valueDisplay = document.getElementById('tile-value');
      if (valueDisplay) {
        valueDisplay.textContent = String(Math.round(value));
      }
    };

    private syncFibersGuiValues(theme: Theme): void {
      if (!theme.shaders?.uniforms) return;

      const fibersGui = document.getElementById('fibers-gui-container');
      if (!fibersGui) return;

      const sliders = fibersGui.querySelectorAll('input[type="range"][data-uniform]');
      sliders.forEach((slider) => {
        const input = slider as HTMLInputElement;
        const uniformName = input.dataset.uniform;
        if (uniformName && theme.shaders?.uniforms?.[uniformName]) {
          const value = theme.shaders.uniforms[uniformName].value as number;
          input.value = String(value);
          const valueDisplay = input.parentElement?.querySelector('.gui-value');
          if (valueDisplay) {
            // Format display value based on uniform type
            if (uniformName === 'u_angle' || uniformName === 'u_lightAngle') {
              valueDisplay.textContent = `${value}째`;
            } else if (value < 0.1 && value > 0) {
              valueDisplay.textContent = value.toFixed(3);
            } else {
              valueDisplay.textContent = String(value);
            }
          }
        }
      });
    }

    private onFibersGuiChange = (e: Event): void => {
      const slider = e.target as HTMLInputElement;
      const uniformName = slider.dataset.uniform;
      if (!uniformName || !this.material) return;

      const value = parseFloat(slider.value);

      // Update uniform
      if (this.material.uniforms[uniformName]) {
        this.material.uniforms[uniformName].value = value;
      }

      // Update display value
      const valueDisplay = slider.parentElement?.querySelector('.gui-value');
      if (valueDisplay) {
        if (uniformName === 'u_angle' || uniformName === 'u_lightAngle') {
          valueDisplay.textContent = `${value}째`;
        } else if (value < 0.1 && value > 0) {
          valueDisplay.textContent = value.toFixed(3);
        } else {
          valueDisplay.textContent = String(value);
        }
      }
    };

    private onFibersReset = (): void => {
      if (!this.currentTheme) return;

      // Reset all uniforms to theme defaults and sync GUI
      this.syncFibersGuiValues(this.currentTheme);

      // Also update the actual material uniforms
      if (this.material && this.currentTheme.shaders?.uniforms) {
        for (const [key, uniform] of Object.entries(this.currentTheme.shaders.uniforms)) {
          if (this.material.uniforms[key] && uniform.type === 'float') {
            this.material.uniforms[key].value = uniform.value;
          }
        }
      }
    };

    private setupEventListeners(): void {
      window.addEventListener('resize', this.onResize);
      window.addEventListener('theme:change', this.onThemeChange as EventListener);

      // Mouse interaction
      this.canvas.addEventListener('mousedown', this.onMouseDown);
      window.addEventListener('mousemove', this.onMouseMove);
      window.addEventListener('mouseup', this.onMouseUp);

      // Touch interaction
      this.canvas.addEventListener('touchstart', this.onTouchStart, { passive: true });
      window.addEventListener('touchmove', this.onTouchMove, { passive: true });
      window.addEventListener('touchend', this.onTouchEnd);

      // Tile size slider
      const tileSlider = document.getElementById('tile-slider');
      if (tileSlider) {
        tileSlider.addEventListener('input', this.onTileSizeChange);
      }

      // Fibers GUI sliders
      const fibersGui = document.getElementById('fibers-gui-container');
      if (fibersGui) {
        const sliders = fibersGui.querySelectorAll('input[type="range"][data-uniform]');
        sliders.forEach((slider) => {
          slider.addEventListener('input', this.onFibersGuiChange);
        });
      }

      // Fibers reset button
      const fibersResetBtn = document.getElementById('fibers-reset-btn');
      if (fibersResetBtn) {
        fibersResetBtn.addEventListener('click', this.onFibersReset);
      }

      // Cleanup on page navigation (Astro)
      document.addEventListener('astro:before-swap', this.dispose);
    }

    private dispose = (): void => {
      cancelAnimationFrame(this.animationId);

      if (this.mesh) {
        this.mesh.geometry.dispose();
      }
      if (this.material) {
        this.material.dispose();
      }
      this.renderer.dispose();

      window.removeEventListener('resize', this.onResize);
      window.removeEventListener('theme:change', this.onThemeChange as EventListener);
      document.removeEventListener('astro:before-swap', this.dispose);

      // Clean up mouse/touch listeners
      this.canvas.removeEventListener('mousedown', this.onMouseDown);
      window.removeEventListener('mousemove', this.onMouseMove);
      window.removeEventListener('mouseup', this.onMouseUp);
      this.canvas.removeEventListener('touchstart', this.onTouchStart);
      window.removeEventListener('touchmove', this.onTouchMove);
      window.removeEventListener('touchend', this.onTouchEnd);

      // Clean up slider listener
      const tileSlider = document.getElementById('tile-slider');
      if (tileSlider) {
        tileSlider.removeEventListener('input', this.onTileSizeChange);
      }

      // Clean up fibers GUI listeners
      const fibersGui = document.getElementById('fibers-gui-container');
      if (fibersGui) {
        const sliders = fibersGui.querySelectorAll('input[type="range"][data-uniform]');
        sliders.forEach((slider) => {
          slider.removeEventListener('input', this.onFibersGuiChange);
        });
      }

      // Clean up fibers reset button
      const fibersResetBtn = document.getElementById('fibers-reset-btn');
      if (fibersResetBtn) {
        fibersResetBtn.removeEventListener('click', this.onFibersReset);
      }
    };
  }

  // Initialize when DOM is ready
  function init(): void {
    const canvas = document.getElementById('theme-background') as HTMLCanvasElement;
    if (canvas) {
      new ThemeBackgroundRenderer(canvas);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
