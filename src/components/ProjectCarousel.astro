---
// ProjectCarousel.astro - Infinite scrolling with center LED pixelation rift
---

<div class="carousel-section">
  <canvas id="carousel-canvas"></canvas>
</div>

<style>
  .carousel-section {
    position: relative;
    width: 100%;
    height: 200px;
    background: transparent;
    transition: background 0.3s ease;
    overflow: visible;
    margin-top: 12rem;
  }

  #carousel-canvas {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 100%;
    height: 500%;
    display: block;
    pointer-events: auto;
  }

  @media (max-width: 768px) {
    .carousel-section {
      height: 120px;
    }
  }
</style>

<script>
  import * as THREE from 'three';

  interface Project {
    name: string;
    link: string;
    isImage?: boolean;
    imagePath?: string;
  }

  const projects: Project[] = [
    { name: 'DEALIFIER', link: 'https://dealifier.com' },
    { name: 'FOX', link: '/', isImage: true, imagePath: '/images/MrFoxSittingLite.png' },
    { name: 'RANGLEY', link: '/rangley' },
    { name: 'SPACE CALCULATOR', link: 'https://alkaline-89z.pages.dev' },
  ];

  // ============================================
  // SETUP
  // ============================================
  const canvas = document.getElementById('carousel-canvas') as HTMLCanvasElement;
  const container = canvas.parentElement as HTMLElement;

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: false, // Disable for crisp pixels
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const scene = new THREE.Scene();

  let width = container.clientWidth;
  let height = container.clientHeight * 5; // Canvas is 500% height

  const camera = new THREE.OrthographicCamera(
    -width / 2, width / 2,
    height / 2, -height / 2,
    -1000, 1000
  );
  camera.position.z = 100;

  // ============================================
  // THEME COLORS
  // ============================================
  function getThemeColors() {
    const theme = document.documentElement.getAttribute('data-theme') || 'dark';
    const isLight = theme === 'light';
    return {
      text: isLight ? '#111111' : '#ffffff',
      bg: 'transparent',
      isLight
    };
  }

  function isLightTheme(): boolean {
    return (document.documentElement.getAttribute('data-theme') || 'dark') === 'light';
  }

  // ============================================
  // CREATE TEXT TEXTURE
  // ============================================
  function createTextTexture(text: string, fontSize: number): THREE.CanvasTexture {
    const colors = getThemeColors();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;

    ctx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
    const metrics = ctx.measureText(text);

    canvas.width = Math.ceil(metrics.width + 40);
    canvas.height = Math.ceil(fontSize * 1.4);

    ctx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
    ctx.fillStyle = colors.text;
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 20, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.NearestFilter;
    texture.magFilter = THREE.NearestFilter;
    texture.generateMipmaps = false;

    return texture;
  }

  // ============================================
  // CREATE IMAGE TEXTURE (for Fox logo etc)
  // ============================================
  function createImageTexture(img: HTMLImageElement, targetHeight: number): THREE.CanvasTexture {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;

    // Scale image to match text height
    const scale = targetHeight / img.height;
    canvas.width = Math.ceil(img.width * scale);
    canvas.height = Math.ceil(targetHeight);

    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.NearestFilter;
    texture.magFilter = THREE.NearestFilter;
    texture.generateMipmaps = false;

    return texture;
  }

  // Preload images
  const imageCache: Map<string, HTMLImageElement> = new Map();

  async function loadImage(path: string): Promise<HTMLImageElement> {
    if (imageCache.has(path)) return imageCache.get(path)!;

    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        imageCache.set(path, img);
        resolve(img);
      };
      img.src = path;
    });
  }

  // Preload all images before creating meshes
  const imageProjects = projects.filter(p => p.isImage && p.imagePath);
  await Promise.all(imageProjects.map(p => loadImage(p.imagePath!)));

  // ============================================
  // LED PIXELATION SHADER
  // ============================================
  const vertexShader = `
    varying vec2 vUv;
    varying vec2 vWorldPos;

    void main() {
      vUv = uv;
      vec4 worldPos = modelMatrix * vec4(position, 1.0);
      vWorldPos = worldPos.xy;
      gl_Position = projectionMatrix * viewMatrix * worldPos;
    }
  `;

  const fragmentShader = `
    uniform sampler2D uTexture;
    uniform float uTime;
    uniform float uScreenWidth;
    uniform vec2 uTextureSize;
    uniform float uPixelSize;
    uniform float uHover;
    uniform float uIsLightTheme;
    varying vec2 vUv;
    varying vec2 vWorldPos;

    // Hash functions for randomness
    float hash(vec2 p) {
      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
    }

    float hash2(vec2 p) {
      return fract(sin(dot(p, vec2(269.5, 183.3))) * 43758.5453);
    }

    void main() {
      // Elliptical rift zone
      float riftWidth = uScreenWidth * 0.12;
      float riftHeight = uTextureSize.y * 0.5;

      vec2 riftPos = vec2(vWorldPos.x / riftWidth, vWorldPos.y / riftHeight);
      float distFromCenter = length(riftPos);

      // Rift intensity: 1 at center, 0 outside
      float riftZone = 1.0 - smoothstep(0.0, 1.0, distFromCenter);

      // === ALWAYS LED PIXELS ===
      vec2 texelSize = vec2(1.0) / uTextureSize;
      float pixelSize = uPixelSize;

      // Snap UV to pixel grid
      vec2 gridUV = floor(vUv / texelSize / pixelSize);
      vec2 pixelUV = gridUV * texelSize * pixelSize + texelSize * pixelSize * 0.5;

      // === RIFT DISTORTION (subtle) ===
      vec2 sampleUV = pixelUV;

      if (riftZone > 0.0) {
        // Gentle scatter
        float scatterIntensity = riftZone * 0.02;
        float noiseX = (hash(gridUV + floor(uTime * 2.0)) - 0.5);
        float noiseY = (hash2(gridUV + floor(uTime * 2.0)) - 0.5);

        sampleUV += vec2(noiseX, noiseY) * scatterIntensity;

        // Subtle wave
        float wave = sin(gridUV.x * 0.3 + uTime * 2.0) * 0.01 * riftZone;
        sampleUV.y += wave;
      }

      sampleUV = clamp(sampleUV, 0.0, 1.0);

      // Sample texture
      vec4 texColor = texture2D(uTexture, sampleUV);

      // === LED DOT RENDERING ===
      vec2 pixelPos = fract(vUv / texelSize / pixelSize);

      // Subtle dot jitter in rift
      if (riftZone > 0.0) {
        float jitter = riftZone * 0.1;
        pixelPos.x += (hash(gridUV * 7.0) - 0.5) * jitter;
        pixelPos.y += (hash2(gridUV * 7.0) - 0.5) * jitter;
      }

      float dotDist = length(pixelPos - 0.5);

      // LED dot shape - rounder, more visible gaps
      float dotRadius = 0.38;
      float dotSoftness = 0.08;

      // Dots shrink and become erratic in rift
      dotRadius -= riftZone * 0.15;
      dotSoftness += riftZone * 0.1;

      float dot = 1.0 - smoothstep(dotRadius - dotSoftness, dotRadius, dotDist);

      // === LED GLOW (subtle bloom around dots) ===
      float glowRadius = 0.6;
      float dotGlow = (1.0 - smoothstep(dotRadius, glowRadius, dotDist)) * 0.15;

      // === FLICKER & GLITCH ===
      float flicker = 1.0;
      if (riftZone > 0.2) {
        // Occasional pixel flicker
        float flickerChance = riftZone * 0.15;
        flicker = hash(gridUV + floor(uTime * 8.0)) > flickerChance ? 1.0 : 0.7;

        // Rare bright pixels
        float stuckOn = hash(gridUV * 3.0) > 0.99 ? 1.3 : 1.0;
        flicker *= stuckOn;
      }

      // === COLOR ===
      vec3 ledColor = texColor.rgb;

      // Chromatic aberration in rift
      if (riftZone > 0.0) {
        float aberration = riftZone * 0.025;
        vec4 texR = texture2D(uTexture, sampleUV + vec2(aberration, 0.0));
        vec4 texB = texture2D(uTexture, sampleUV - vec2(aberration, 0.0));

        ledColor = vec3(texR.r, texColor.g, texB.b);

        // Hot orange/red tint in destruction zone - darker for light theme
        vec3 riftTintDark = vec3(0.95, 0.3, 0.1);
        vec3 riftTintLight = vec3(0.8, 0.2, 0.05);
        vec3 riftTint = mix(riftTintDark, riftTintLight, uIsLightTheme);
        float tintStrength = mix(0.6, 0.75, uIsLightTheme);
        ledColor = mix(ledColor, riftTint, riftZone * tintStrength);

        // Boost brightness in rift (less boost in light theme)
        float brightnessBoost = mix(0.8, 0.3, uIsLightTheme);
        ledColor *= 1.0 + riftZone * brightnessBoost;
      }

      // === FINAL COMPOSITE ===
      float alpha = texColor.a * dot * flicker;

      // Add glow
      alpha = max(alpha, texColor.a * dotGlow);

      // Random dead pixels outside rift (subtle LED imperfection)
      float deadPixel = hash(gridUV * 13.0) > 0.995 ? 0.3 : 1.0;
      alpha *= deadPixel;

      vec4 color = vec4(ledColor, alpha);

      // Hover effect - different for light vs dark theme
      if (uIsLightTheme > 0.5) {
        // Light theme: warm orange glow, slight darkening for contrast
        color.rgb = mix(color.rgb, vec3(0.9, 0.4, 0.1), uHover * 0.5);
      } else {
        // Dark theme: brighten toward warm white
        color.rgb *= 1.0 + uHover * 1.2;
        color.rgb = mix(color.rgb, vec3(1.0, 0.95, 0.8), uHover * 0.3);
      }

      // Vertical fade at edges
      float edgeFade = smoothstep(0.0, 0.25, vUv.y) * smoothstep(1.0, 0.75, vUv.y);
      color.a *= edgeFade;

      gl_FragColor = color;
    }
  `;

  // ============================================
  // CREATE PROJECT MESHES
  // ============================================
  interface ProjectMesh {
    mesh: THREE.Mesh;
    material: THREE.ShaderMaterial;
    width: number;
    height: number;
    hitWidth: number; // Actual content width for hover detection
    link: string;
    project: Project;
  }

  const projectMeshes: ProjectMesh[] = [];
  const fontSize = Math.min(100, width * 0.1);
  const textureHeight = Math.ceil(fontSize * 1.4);
  const gap = 120;
  const pixelSize = 3.0; // Size of LED pixels

  // Calculate total width (accounting for both text and images)
  let totalWidth = 0;
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d')!;
  tempCtx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

  projects.forEach(p => {
    if (p.isImage && p.imagePath) {
      const img = imageCache.get(p.imagePath);
      if (img) {
        const scale = textureHeight / img.height;
        totalWidth += Math.ceil(img.width * scale) + gap;
      }
    } else {
      totalWidth += Math.ceil(tempCtx.measureText(p.name).width + 40) + gap;
    }
  });

  // Create copies for seamless loop
  const copies = Math.ceil((width * 4) / totalWidth) + 2;
  let xOffset = -totalWidth;

  for (let copy = 0; copy < copies; copy++) {
    projects.forEach((project) => {
      let texture: THREE.CanvasTexture;
      let texWidth: number;
      let texHeight: number;
      let hitWidth: number;

      if (project.isImage && project.imagePath) {
        // Image-based item (Fox logo)
        const img = imageCache.get(project.imagePath)!;
        texture = createImageTexture(img, textureHeight);
        texWidth = texture.image.width;
        texHeight = texture.image.height;
        hitWidth = texWidth; // Images use full width
      } else {
        // Text-based item
        texture = createTextTexture(project.name, fontSize);
        texWidth = texture.image.width;
        texHeight = texture.image.height;
        // Get actual text width without padding
        hitWidth = tempCtx.measureText(project.name).width;
      }

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTexture: { value: texture },
          uTime: { value: 0 },
          uScreenWidth: { value: width },
          uTextureSize: { value: new THREE.Vector2(texWidth, texHeight) },
          uPixelSize: { value: pixelSize },
          uHover: { value: 0.0 },
          uIsLightTheme: { value: isLightTheme() ? 1.0 : 0.0 },
        },
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
      });

      const geometry = new THREE.PlaneGeometry(texWidth, texHeight);
      const mesh = new THREE.Mesh(geometry, material);

      mesh.position.x = xOffset + texWidth / 2;
      mesh.position.y = 0;
      mesh.userData.baseX = mesh.position.x;

      scene.add(mesh);
      projectMeshes.push({
        mesh,
        material,
        width: texWidth,
        height: texHeight,
        hitWidth,
        link: project.link,
        project
      });

      xOffset += texWidth + gap;
    });
  }

  // ============================================
  // CENTER GLOW EFFECT - LED PIXEL RIFT
  // ============================================
  const glowWidth = 500;
  const glowHeight = Math.min(height * 0.6, 600); // Capped at 600px max

  const glowGeometry = new THREE.PlaneGeometry(glowWidth, glowHeight);
  const glowMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uResolution: { value: new THREE.Vector2(glowWidth, glowHeight) },
      uIsLightTheme: { value: isLightTheme() ? 1.0 : 0.0 },
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uIsLightTheme;
      varying vec2 vUv;

      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
      }

      void main() {
        vec2 center = vUv - 0.5;

        // Diamond/eye shape - vertical columns meeting at center
        float absX = abs(center.x);
        float absY = abs(center.y);

        // Create the diamond envelope - tighter at top/bottom, wider at middle
        float diamondDist = absX * 1.8 + absY * 1.0;

        // Also use radial for the glow falloff (wider spread)
        float radialDist = length(vec2(center.x * 1.5, center.y * 0.7));

        // === LED PIXEL GRID ===
        float pixelWidth = 3.0;  // Width of each LED column
        float pixelHeight = 4.0; // Height of each LED row
        float gapX = 1.5;        // Gap between columns
        float gapY = 1.0;        // Gap between rows

        // Calculate pixel coordinates
        float cellWidth = pixelWidth + gapX;
        float cellHeight = pixelHeight + gapY;

        vec2 pixelCoord = vUv * uResolution;
        vec2 cellPos = mod(pixelCoord, vec2(cellWidth, cellHeight));
        vec2 cellIndex = floor(pixelCoord / vec2(cellWidth, cellHeight));

        // Is this pixel inside an LED dot?
        float inPixelX = step(cellPos.x, pixelWidth);
        float inPixelY = step(cellPos.y, pixelHeight);
        float inPixel = inPixelX * inPixelY;

        // Slight variation per pixel
        float pixelVariation = hash(cellIndex) * 0.15 + 0.85;

        // === COLOR GRADIENT - theme aware ===
        // Dark theme: bright warm colors for additive blending
        // Light theme: darker, more saturated colors for normal blending
        vec3 coreColor, innerColor, midColor, outerColor, edgeColor;

        if (uIsLightTheme > 0.5) {
          // Light theme - richer, darker colors that show on light bg
          coreColor = vec3(0.95, 0.7, 0.1);
          innerColor = vec3(0.9, 0.5, 0.05);
          midColor = vec3(0.85, 0.3, 0.02);
          outerColor = vec3(0.6, 0.12, 0.01);
          edgeColor = vec3(0.35, 0.05, 0.0);
        } else {
          // Dark theme - original bright colors
          coreColor = vec3(0.95, 0.92, 0.3);
          innerColor = vec3(0.9, 0.75, 0.15);
          midColor = vec3(0.95, 0.45, 0.08);
          outerColor = vec3(0.7, 0.15, 0.02);
          edgeColor = vec3(0.4, 0.05, 0.01);
        }

        // Build color based on distance from center
        vec3 color = edgeColor;
        color = mix(color, outerColor, smoothstep(0.5, 0.35, radialDist));
        color = mix(color, midColor, smoothstep(0.35, 0.22, radialDist));
        color = mix(color, innerColor, smoothstep(0.22, 0.1, radialDist));
        color = mix(color, coreColor, smoothstep(0.1, 0.0, radialDist));

        // === INTENSITY ===
        // Diamond falloff - more gradual for wider spread
        float diamondMask = 1.0 - smoothstep(0.25, 0.7, diamondDist);

        // Extra brightness in center column
        float centerBoost = 1.0 - smoothstep(0.0, 0.2, absX);
        centerBoost = centerBoost * 0.5 + 1.0;

        // Vertical intensity falloff - smooth taper to zero at edges
        float verticalFade = 1.0 - smoothstep(0.25, 0.5, absY);

        // Combine
        float intensity = diamondMask * verticalFade * centerBoost;
        intensity *= inPixel * pixelVariation;

        // Subtle flicker
        float flicker = 0.95 + 0.05 * sin(uTime * 3.0 + hash(cellIndex) * 6.28);
        intensity *= flicker;

        // Boost overall brightness - more for light theme since normal blending is less impactful
        float brightnessMultiplier = mix(0.85, 1.2, uIsLightTheme);
        intensity *= brightnessMultiplier;

        gl_FragColor = vec4(color * intensity, intensity);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: isLightTheme() ? THREE.NormalBlending : THREE.AdditiveBlending,
  });

  const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
  glowMesh.position.z = 50;
  scene.add(glowMesh);

  // ============================================
  // ANIMATION
  // ============================================
  let scrollX = 0;
  const scrollSpeed = 1.2;
  let time = 0;
  let lastTime = performance.now();
  let hoveredItem: ProjectMesh | null = null;

  function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    const delta = Math.min((now - lastTime) / 16.67, 3);
    lastTime = now;

    time += 0.016 * delta;
    scrollX += scrollSpeed * delta;

    if (scrollX > totalWidth) {
      scrollX -= totalWidth;
    }

    const wrapWidth = totalWidth * copies;

    projectMeshes.forEach((item) => {
      let x = item.mesh.userData.baseX - scrollX;

      // Wrap around
      x = ((x % wrapWidth) + wrapWidth) % wrapWidth;
      x -= wrapWidth / 2;

      item.mesh.position.x = x;
      item.material.uniforms.uTime.value = time;
      item.material.uniforms.uScreenWidth.value = width;

      // Smooth hover animation
      const targetHover = item === hoveredItem ? 1.0 : 0.0;
      const currentHover = item.material.uniforms.uHover.value;
      item.material.uniforms.uHover.value += (targetHover - currentHover) * 0.2;

      // Scale up on hover
      const baseScale = 1.0;
      const hoverScale = 1.15;
      const scale = baseScale + (hoverScale - baseScale) * item.material.uniforms.uHover.value;
      item.mesh.scale.set(scale, scale, 1);
    });

    glowMaterial.uniforms.uTime.value = time;

    renderer.render(scene, camera);
  }

  // ============================================
  // RESIZE
  // ============================================
  function onResize() {
    width = container.clientWidth;
    height = container.clientHeight * 5; // Canvas is 500% height

    renderer.setSize(width, height);

    camera.left = -width / 2;
    camera.right = width / 2;
    camera.top = height / 2;
    camera.bottom = -height / 2;
    camera.updateProjectionMatrix();
  }

  window.addEventListener('resize', onResize);
  onResize();

  // ============================================
  // HOVER & CLICK HANDLING
  // ============================================
  canvas.style.cursor = 'pointer';

  function getItemAtPosition(clientX: number, clientY: number): ProjectMesh | null {
    const rect = canvas.getBoundingClientRect();
    // X: canvas center = scene X 0
    const mouseX = clientX - rect.left - rect.width / 2;
    // Y: canvas center = scene Y 0, Y increases upward in scene
    const mouseY = (rect.height / 2) - (clientY - rect.top);

    for (const item of projectMeshes) {
      // Horizontal bounds using hitWidth
      const halfHitWidth = item.hitWidth / 2;
      // Vertical bounds - add some padding for easier interaction
      const halfHeight = item.height / 2 + 20;

      const meshX = item.mesh.position.x;
      const meshY = item.mesh.position.y;

      if (mouseX >= meshX - halfHitWidth && mouseX <= meshX + halfHitWidth &&
          mouseY >= meshY - halfHeight && mouseY <= meshY + halfHeight) {
        return item;
      }
    }
    return null;
  }

  canvas.addEventListener('mousemove', (e) => {
    hoveredItem = getItemAtPosition(e.clientX, e.clientY);
  });

  canvas.addEventListener('mouseleave', () => {
    hoveredItem = null;
  });

  canvas.addEventListener('click', (e) => {
    const item = getItemAtPosition(e.clientX, e.clientY);
    if (item) {
      if (item.link.startsWith('http')) {
        window.open(item.link, '_blank');
      } else {
        window.location.href = item.link;
      }
    }
  });

  // ============================================
  // THEME CHANGE
  // ============================================
  const observer = new MutationObserver(() => {
    const lightTheme = isLightTheme();

    projectMeshes.forEach((item) => {
      // Update theme uniform for all items
      item.material.uniforms.uIsLightTheme.value = lightTheme ? 1.0 : 0.0;

      // Skip texture update for image items - they don't change with theme
      if (item.project.isImage) return;

      const newTexture = createTextTexture(item.project.name, fontSize);
      item.material.uniforms.uTexture.value.dispose();
      item.material.uniforms.uTexture.value = newTexture;
      item.material.uniforms.uTextureSize.value.set(newTexture.image.width, newTexture.image.height);
    });

    // Update glow for theme
    glowMaterial.uniforms.uIsLightTheme.value = lightTheme ? 1.0 : 0.0;
    glowMaterial.blending = lightTheme ? THREE.NormalBlending : THREE.AdditiveBlending;
    glowMaterial.needsUpdate = true;
  });

  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['data-theme']
  });

  animate();
</script>
