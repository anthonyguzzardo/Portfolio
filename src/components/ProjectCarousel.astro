---
// ProjectCarousel.astro - Infinite scrolling text carousel
---

<div class="carousel-section">
  <canvas id="carousel-canvas"></canvas>
</div>

<style>
  .carousel-section {
    position: relative;
    width: 100%;
    height: 200px;
    background: transparent;
    overflow: visible;
    margin-top: 12rem;
  }

  #carousel-canvas {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 100%;
    height: 100%;
    display: block;
    pointer-events: auto;
  }

  @media (max-width: 768px) {
    .carousel-section {
      height: 120px;
    }
  }
</style>

<script>
  import * as THREE from 'three';

  // ============================================
  // TYPES
  // ============================================
  interface Project {
    name: string;
    link: string;
    isImage?: boolean;
    imagePath?: string;
  }

  interface ProjectMesh {
    mesh: THREE.Mesh;
    material: THREE.ShaderMaterial;
    width: number;
    height: number;
    hitWidth: number;
    link: string;
    project: Project;
  }

  // ============================================
  // DATA
  // ============================================
  const projects: Project[] = [
    { name: 'DEALIFIER', link: 'https://dealifier.com' },
    { name: 'FOX', link: '/', isImage: true, imagePath: '/images/MrFoxSittingLite.png' },
    { name: 'RANGLEY', link: '/rangley' },
    { name: 'SPACE CALCULATOR', link: 'https://alkaline-89z.pages.dev' },
  ];

  // ============================================
  // THEME HELPERS
  // ============================================
  function getThemeColors() {
    const theme = document.documentElement.getAttribute('data-theme') || 'dark';
    const isLight = theme === 'light';
    return {
      text: isLight ? '#111111' : '#ffffff',
      isLight
    };
  }

  function isLightTheme(): boolean {
    return (document.documentElement.getAttribute('data-theme') || 'dark') === 'light';
  }

  // ============================================
  // SETUP
  // ============================================
  const canvas = document.getElementById('carousel-canvas') as HTMLCanvasElement;
  const container = canvas.parentElement as HTMLElement;

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: false,
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const scene = new THREE.Scene();

  let width = container.clientWidth;
  let height = container.clientHeight;

  const camera = new THREE.OrthographicCamera(
    -width / 2, width / 2,
    height / 2, -height / 2,
    -1000, 1000
  );
  camera.position.z = 100;

  // ============================================
  // SIMPLE VERTEX/FRAGMENT SHADERS
  // ============================================
  const vertexShader = `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uHover;
    uniform float uIsLightTheme;
    varying vec2 vUv;

    void main() {
      vec4 texColor = texture2D(uTexture, vUv);
      vec3 color = texColor.rgb;

      // Hover effect: slight color boost
      color *= 1.0 + uHover * 0.3;

      gl_FragColor = vec4(color, texColor.a);
    }
  `;

  // ============================================
  // TEXTURE CREATION
  // ============================================
  function createTextTexture(text: string, fontSize: number): THREE.CanvasTexture {
    const colors = getThemeColors();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;

    ctx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
    const metrics = ctx.measureText(text);

    canvas.width = Math.ceil(metrics.width + 40);
    canvas.height = Math.ceil(fontSize * 1.4);

    ctx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
    ctx.fillStyle = colors.text;
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 20, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;

    return texture;
  }

  function createImageTexture(img: HTMLImageElement, targetHeight: number): THREE.CanvasTexture {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;

    const scale = targetHeight / img.height;
    canvas.width = Math.ceil(img.width * scale);
    canvas.height = Math.ceil(targetHeight);

    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;

    return texture;
  }

  // ============================================
  // IMAGE PRELOADING
  // ============================================
  const imageCache: Map<string, HTMLImageElement> = new Map();

  async function loadImage(path: string): Promise<HTMLImageElement> {
    if (imageCache.has(path)) return imageCache.get(path)!;

    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        imageCache.set(path, img);
        resolve(img);
      };
      img.src = path;
    });
  }

  const imageProjects = projects.filter(p => p.isImage && p.imagePath);
  await Promise.all(imageProjects.map(p => loadImage(p.imagePath!)));

  // ============================================
  // CREATE PROJECT MESHES
  // ============================================
  const projectMeshes: ProjectMesh[] = [];
  const fontSize = Math.min(100, width * 0.1);
  const textureHeight = Math.ceil(fontSize * 1.4);
  const gap = 120;

  // Calculate total width
  let totalWidth = 0;
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d')!;
  tempCtx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

  projects.forEach(p => {
    if (p.isImage && p.imagePath) {
      const img = imageCache.get(p.imagePath);
      if (img) {
        const scale = textureHeight / img.height;
        totalWidth += Math.ceil(img.width * scale) + gap;
      }
    } else {
      totalWidth += Math.ceil(tempCtx.measureText(p.name).width + 40) + gap;
    }
  });

  // Create copies for seamless loop
  const copies = Math.ceil((width * 4) / totalWidth) + 2;
  let xOffset = -totalWidth;

  for (let copy = 0; copy < copies; copy++) {
    projects.forEach((project) => {
      let texture: THREE.CanvasTexture;
      let texWidth: number;
      let texHeight: number;
      let hitWidth: number;

      if (project.isImage && project.imagePath) {
        const img = imageCache.get(project.imagePath)!;
        texture = createImageTexture(img, textureHeight);
        texWidth = texture.image.width;
        texHeight = texture.image.height;
        hitWidth = texWidth;
      } else {
        texture = createTextTexture(project.name, fontSize);
        texWidth = texture.image.width;
        texHeight = texture.image.height;
        hitWidth = tempCtx.measureText(project.name).width;
      }

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTexture: { value: texture },
          uHover: { value: 0.0 },
          uIsLightTheme: { value: isLightTheme() ? 1.0 : 0.0 },
        },
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
      });

      const geometry = new THREE.PlaneGeometry(texWidth, texHeight);
      const mesh = new THREE.Mesh(geometry, material);

      mesh.position.x = xOffset + texWidth / 2;
      mesh.position.y = 0;
      mesh.userData.baseX = mesh.position.x;

      scene.add(mesh);
      projectMeshes.push({
        mesh,
        material,
        width: texWidth,
        height: texHeight,
        hitWidth,
        link: project.link,
        project
      });

      xOffset += texWidth + gap;
    });
  }

  // ============================================
  // ANIMATION
  // ============================================
  let scrollX = 0;
  const scrollSpeed = 1.2;
  let lastTime = performance.now();
  let hoveredItem: ProjectMesh | null = null;

  function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    const delta = Math.min((now - lastTime) / 16.67, 3);
    lastTime = now;

    scrollX += scrollSpeed * delta;

    if (scrollX > totalWidth) {
      scrollX -= totalWidth;
    }

    const wrapWidth = totalWidth * copies;

    projectMeshes.forEach((item) => {
      let x = item.mesh.userData.baseX - scrollX;
      x = ((x % wrapWidth) + wrapWidth) % wrapWidth;
      x -= wrapWidth / 2;

      item.mesh.position.x = x;

      const targetHover = item === hoveredItem ? 1.0 : 0.0;
      const currentHover = item.material.uniforms.uHover.value;
      item.material.uniforms.uHover.value += (targetHover - currentHover) * 0.2;

      const baseScale = 1.0;
      const hoverScale = 1.15;
      const scale = baseScale + (hoverScale - baseScale) * item.material.uniforms.uHover.value;
      item.mesh.scale.set(scale, scale, 1);
    });

    renderer.render(scene, camera);
  }

  // ============================================
  // RESIZE
  // ============================================
  function onResize() {
    width = container.clientWidth;
    height = container.clientHeight;

    renderer.setSize(width, height);

    camera.left = -width / 2;
    camera.right = width / 2;
    camera.top = height / 2;
    camera.bottom = -height / 2;
    camera.updateProjectionMatrix();
  }

  window.addEventListener('resize', onResize);
  onResize();

  // ============================================
  // HOVER & CLICK
  // ============================================
  canvas.style.cursor = 'pointer';

  function getItemAtPosition(clientX: number, clientY: number): ProjectMesh | null {
    const rect = canvas.getBoundingClientRect();
    const mouseX = clientX - rect.left - rect.width / 2;
    const mouseY = (rect.height / 2) - (clientY - rect.top);

    for (const item of projectMeshes) {
      const halfHitWidth = item.hitWidth / 2;
      const halfHeight = item.height / 2 + 20;
      const meshX = item.mesh.position.x;
      const meshY = item.mesh.position.y;

      if (mouseX >= meshX - halfHitWidth && mouseX <= meshX + halfHitWidth &&
          mouseY >= meshY - halfHeight && mouseY <= meshY + halfHeight) {
        return item;
      }
    }
    return null;
  }

  canvas.addEventListener('mousemove', (e) => {
    hoveredItem = getItemAtPosition(e.clientX, e.clientY);
  });

  canvas.addEventListener('mouseleave', () => {
    hoveredItem = null;
  });

  canvas.addEventListener('click', (e) => {
    const item = getItemAtPosition(e.clientX, e.clientY);
    if (item) {
      if (item.link.startsWith('http')) {
        window.open(item.link, '_blank');
      } else {
        window.location.href = item.link;
      }
    }
  });

  // ============================================
  // THEME CHANGE
  // ============================================
  const observer = new MutationObserver(() => {
    const lightTheme = isLightTheme();

    projectMeshes.forEach((item) => {
      item.material.uniforms.uIsLightTheme.value = lightTheme ? 1.0 : 0.0;

      if (item.project.isImage) return;

      const newTexture = createTextTexture(item.project.name, fontSize);
      item.material.uniforms.uTexture.value.dispose();
      item.material.uniforms.uTexture.value = newTexture;
    });
  });

  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['data-theme']
  });

  animate();
</script>
