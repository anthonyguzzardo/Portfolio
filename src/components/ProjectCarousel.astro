---
// ProjectCarousel.astro - Infinite scrolling with center LED pixelation
// Dark theme: Black hole with accretion disk
// Light theme: Flow gradient (NO distortion)
---

<div class="carousel-section">
  <canvas id="carousel-canvas"></canvas>
</div>

<style>
  .carousel-section {
    position: relative;
    width: 100%;
    height: 200px;
    background: transparent;
    transition: background 0.3s ease;
    overflow: visible;
    margin-top: 12rem;
  }

  #carousel-canvas {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 100%;
    height: 500%;
    display: block;
    pointer-events: auto;
  }

  @media (max-width: 768px) {
    .carousel-section {
      height: 120px;
    }
  }
</style>

<script>
  import * as THREE from 'three';
  import { blackHoleVertexShader, blackHoleFragmentShader, BLACK_HOLE_DEFAULTS } from './shaders/BlackHoleShader';
  import { flowGradientVertexShader, flowGradientFragmentShader } from './shaders/FlowGradientShader';
  import { ledTextVertexShader, ledTextFragmentShader } from './shaders/LEDTextShader';

  // ============================================
  // TYPES
  // ============================================
  interface Project {
    name: string;
    link: string;
    isImage?: boolean;
    imagePath?: string;
  }

  interface ProjectMesh {
    mesh: THREE.Mesh;
    material: THREE.ShaderMaterial;
    width: number;
    height: number;
    hitWidth: number;
    link: string;
    project: Project;
  }

  // ============================================
  // DATA
  // ============================================
  const projects: Project[] = [
    { name: 'DEALIFIER', link: 'https://dealifier.com' },
    { name: 'FOX', link: '/', isImage: true, imagePath: '/images/MrFoxSittingLite.png' },
    { name: 'RANGLEY', link: '/rangley' },
    { name: 'SPACE CALCULATOR', link: 'https://alkaline-89z.pages.dev' },
  ];

  // ============================================
  // THEME HELPERS
  // ============================================
  function getThemeColors() {
    const theme = document.documentElement.getAttribute('data-theme') || 'dark';
    const isLight = theme === 'light';
    return {
      text: isLight ? '#111111' : '#ffffff',
      bg: 'transparent',
      isLight
    };
  }

  function isLightTheme(): boolean {
    return (document.documentElement.getAttribute('data-theme') || 'dark') === 'light';
  }

  // ============================================
  // SETUP
  // ============================================
  const canvas = document.getElementById('carousel-canvas') as HTMLCanvasElement;
  const container = canvas.parentElement as HTMLElement;

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: false,
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const scene = new THREE.Scene();

  let width = container.clientWidth;
  let height = container.clientHeight * 5;

  const camera = new THREE.OrthographicCamera(
    -width / 2, width / 2,
    height / 2, -height / 2,
    -1000, 1000
  );
  camera.position.z = 100;

  // ============================================
  // TEXTURE CREATION
  // ============================================
  function createTextTexture(text: string, fontSize: number): THREE.CanvasTexture {
    const colors = getThemeColors();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;

    ctx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
    const metrics = ctx.measureText(text);

    canvas.width = Math.ceil(metrics.width + 40);
    canvas.height = Math.ceil(fontSize * 1.4);

    ctx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
    ctx.fillStyle = colors.text;
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 20, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;

    return texture;
  }

  function createImageTexture(img: HTMLImageElement, targetHeight: number): THREE.CanvasTexture {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;

    const scale = targetHeight / img.height;
    canvas.width = Math.ceil(img.width * scale);
    canvas.height = Math.ceil(targetHeight);

    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;

    return texture;
  }

  // ============================================
  // IMAGE PRELOADING
  // ============================================
  const imageCache: Map<string, HTMLImageElement> = new Map();

  async function loadImage(path: string): Promise<HTMLImageElement> {
    if (imageCache.has(path)) return imageCache.get(path)!;

    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        imageCache.set(path, img);
        resolve(img);
      };
      img.src = path;
    });
  }

  const imageProjects = projects.filter(p => p.isImage && p.imagePath);
  await Promise.all(imageProjects.map(p => loadImage(p.imagePath!)));

  // ============================================
  // CREATE PROJECT MESHES
  // ============================================
  const projectMeshes: ProjectMesh[] = [];
  const fontSize = Math.min(100, width * 0.1);
  const textureHeight = Math.ceil(fontSize * 1.4);
  const gap = 120;
  const pixelSize = 3.0;

  // Calculate total width
  let totalWidth = 0;
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d')!;
  tempCtx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

  projects.forEach(p => {
    if (p.isImage && p.imagePath) {
      const img = imageCache.get(p.imagePath);
      if (img) {
        const scale = textureHeight / img.height;
        totalWidth += Math.ceil(img.width * scale) + gap;
      }
    } else {
      totalWidth += Math.ceil(tempCtx.measureText(p.name).width + 40) + gap;
    }
  });

  // Create copies for seamless loop
  const copies = Math.ceil((width * 4) / totalWidth) + 2;
  let xOffset = -totalWidth;

  for (let copy = 0; copy < copies; copy++) {
    projects.forEach((project) => {
      let texture: THREE.CanvasTexture;
      let texWidth: number;
      let texHeight: number;
      let hitWidth: number;

      if (project.isImage && project.imagePath) {
        const img = imageCache.get(project.imagePath)!;
        texture = createImageTexture(img, textureHeight);
        texWidth = texture.image.width;
        texHeight = texture.image.height;
        hitWidth = texWidth;
      } else {
        texture = createTextTexture(project.name, fontSize);
        texWidth = texture.image.width;
        texHeight = texture.image.height;
        hitWidth = tempCtx.measureText(project.name).width;
      }

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTexture: { value: texture },
          uTime: { value: 0 },
          uScreenWidth: { value: width },
          uTextureSize: { value: new THREE.Vector2(texWidth, texHeight) },
          uPixelSize: { value: pixelSize },
          uHover: { value: 0.0 },
          uIsLightTheme: { value: isLightTheme() ? 1.0 : 0.0 },
          uBlackHoleRadius: { value: BLACK_HOLE_DEFAULTS.blackHoleRadius },
          uAccretionRadius: { value: BLACK_HOLE_DEFAULTS.accretionRadius },
        },
        vertexShader: ledTextVertexShader,
        fragmentShader: ledTextFragmentShader,
        transparent: true,
        depthWrite: false,
      });

      const geometry = new THREE.PlaneGeometry(texWidth, texHeight);
      const mesh = new THREE.Mesh(geometry, material);

      mesh.position.x = xOffset + texWidth / 2;
      mesh.position.y = 0;
      mesh.userData.baseX = mesh.position.x;

      scene.add(mesh);
      projectMeshes.push({
        mesh,
        material,
        width: texWidth,
        height: texHeight,
        hitWidth,
        link: project.link,
        project
      });

      xOffset += texWidth + gap;
    });
  }

  // ============================================
  // BACKGROUND MESHES
  // ============================================
  const glowWidth = width * 1.5;
  const glowHeight = height * 1.2;
  const glowGeometry = new THREE.PlaneGeometry(glowWidth, glowHeight);

  // Dark theme: Black hole
  const initialScale = isLightTheme() ? 0.0 : 1.0;
  const blackHoleMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uResolution: { value: new THREE.Vector2(glowWidth, glowHeight) },
      uIsLightTheme: { value: isLightTheme() ? 1.0 : 0.0 },
      uBlackHoleRadius: { value: BLACK_HOLE_DEFAULTS.blackHoleRadius * initialScale },
      uAccretionRadius: { value: BLACK_HOLE_DEFAULTS.accretionRadius * initialScale },
      uOpacity: { value: initialScale },
    },
    vertexShader: blackHoleVertexShader,
    fragmentShader: blackHoleFragmentShader,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
  });

  const blackHoleMesh = new THREE.Mesh(glowGeometry, blackHoleMaterial);
  blackHoleMesh.position.z = -10;
  scene.add(blackHoleMesh);

  // Light theme: Flow gradient
  const flowGradientMaterial = new THREE.ShaderMaterial({
    uniforms: {
      u_time: { value: 0 },
      u_resolution: { value: new THREE.Vector2(glowWidth, glowHeight) },
      u_opacity: { value: isLightTheme() ? 1.0 : 0.0 },
    },
    vertexShader: flowGradientVertexShader,
    fragmentShader: flowGradientFragmentShader,
    transparent: true,
    depthWrite: false,
  });

  const flowMesh = new THREE.Mesh(glowGeometry.clone(), flowGradientMaterial);
  flowMesh.position.z = -11;
  scene.add(flowMesh);

  // ============================================
  // ANIMATION
  // ============================================
  let scrollX = 0;
  const scrollSpeed = 1.2;
  let time = 0;
  let lastTime = performance.now();
  let hoveredItem: ProjectMesh | null = null;

  // Theme transition
  let targetFlowOpacity = isLightTheme() ? 1.0 : 0.0;
  let targetBlackHoleScale = isLightTheme() ? 0.0 : 1.0;
  const transitionSpeed = 0.04;

  function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    const delta = Math.min((now - lastTime) / 16.67, 3);
    lastTime = now;

    time += 0.016 * delta;
    scrollX += scrollSpeed * delta;

    if (scrollX > totalWidth) {
      scrollX -= totalWidth;
    }

    const wrapWidth = totalWidth * copies;

    projectMeshes.forEach((item) => {
      let x = item.mesh.userData.baseX - scrollX;
      x = ((x % wrapWidth) + wrapWidth) % wrapWidth;
      x -= wrapWidth / 2;

      item.mesh.position.x = x;
      item.material.uniforms.uTime.value = time;
      item.material.uniforms.uScreenWidth.value = width;

      const targetHover = item === hoveredItem ? 1.0 : 0.0;
      const currentHover = item.material.uniforms.uHover.value;
      item.material.uniforms.uHover.value += (targetHover - currentHover) * 0.2;

      const baseScale = 1.0;
      const hoverScale = 1.15;
      const scale = baseScale + (hoverScale - baseScale) * item.material.uniforms.uHover.value;
      item.mesh.scale.set(scale, scale, 1);
    });

    blackHoleMaterial.uniforms.uTime.value = time;
    flowGradientMaterial.uniforms.u_time.value = time;

    // Smooth theme transition
    const currentFlowOpacity = flowGradientMaterial.uniforms.u_opacity.value;
    flowGradientMaterial.uniforms.u_opacity.value += (targetFlowOpacity - currentFlowOpacity) * transitionSpeed * delta;

    // Black hole expands/shrinks
    const currentScale = blackHoleMaterial.uniforms.uBlackHoleRadius.value / BLACK_HOLE_DEFAULTS.blackHoleRadius;
    const newScale = currentScale + (targetBlackHoleScale - currentScale) * transitionSpeed * delta;
    blackHoleMaterial.uniforms.uBlackHoleRadius.value = newScale * BLACK_HOLE_DEFAULTS.blackHoleRadius;
    blackHoleMaterial.uniforms.uAccretionRadius.value = newScale * BLACK_HOLE_DEFAULTS.accretionRadius;
    blackHoleMaterial.uniforms.uOpacity.value = newScale; // Fade with scale

    renderer.render(scene, camera);
  }

  // ============================================
  // RESIZE
  // ============================================
  function onResize() {
    width = container.clientWidth;
    height = container.clientHeight * 5;

    renderer.setSize(width, height);

    camera.left = -width / 2;
    camera.right = width / 2;
    camera.top = height / 2;
    camera.bottom = -height / 2;
    camera.updateProjectionMatrix();

    const newGlowWidth = width * 1.5;
    const newGlowHeight = height * 1.2;

    blackHoleMesh.geometry.dispose();
    blackHoleMesh.geometry = new THREE.PlaneGeometry(newGlowWidth, newGlowHeight);
    blackHoleMaterial.uniforms.uResolution.value.set(newGlowWidth, newGlowHeight);

    flowMesh.geometry.dispose();
    flowMesh.geometry = new THREE.PlaneGeometry(newGlowWidth, newGlowHeight);
    flowGradientMaterial.uniforms.u_resolution.value.set(newGlowWidth, newGlowHeight);
  }

  window.addEventListener('resize', onResize);
  onResize();

  // ============================================
  // HOVER & CLICK
  // ============================================
  canvas.style.cursor = 'pointer';

  function getItemAtPosition(clientX: number, clientY: number): ProjectMesh | null {
    const rect = canvas.getBoundingClientRect();
    const mouseX = clientX - rect.left - rect.width / 2;
    const mouseY = (rect.height / 2) - (clientY - rect.top);

    for (const item of projectMeshes) {
      const halfHitWidth = item.hitWidth / 2;
      const halfHeight = item.height / 2 + 20;
      const meshX = item.mesh.position.x;
      const meshY = item.mesh.position.y;

      if (mouseX >= meshX - halfHitWidth && mouseX <= meshX + halfHitWidth &&
          mouseY >= meshY - halfHeight && mouseY <= meshY + halfHeight) {
        return item;
      }
    }
    return null;
  }

  canvas.addEventListener('mousemove', (e) => {
    hoveredItem = getItemAtPosition(e.clientX, e.clientY);
  });

  canvas.addEventListener('mouseleave', () => {
    hoveredItem = null;
  });

  canvas.addEventListener('click', (e) => {
    const item = getItemAtPosition(e.clientX, e.clientY);
    if (item) {
      if (item.link.startsWith('http')) {
        window.open(item.link, '_blank');
      } else {
        window.location.href = item.link;
      }
    }
  });

  // ============================================
  // THEME CHANGE
  // ============================================
  const observer = new MutationObserver(() => {
    const lightTheme = isLightTheme();

    // Set targets for smooth transition
    targetBlackHoleScale = lightTheme ? 0.0 : 1.0;
    targetFlowOpacity = lightTheme ? 1.0 : 0.0;

    projectMeshes.forEach((item) => {
      item.material.uniforms.uIsLightTheme.value = lightTheme ? 1.0 : 0.0;

      if (item.project.isImage) return;

      const newTexture = createTextTexture(item.project.name, fontSize);
      item.material.uniforms.uTexture.value.dispose();
      item.material.uniforms.uTexture.value = newTexture;
      item.material.uniforms.uTextureSize.value.set(newTexture.image.width, newTexture.image.height);
    });

    blackHoleMaterial.uniforms.uIsLightTheme.value = lightTheme ? 1.0 : 0.0;
  });

  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['data-theme']
  });

  animate();
</script>
