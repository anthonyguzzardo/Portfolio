---
interface Props {
  tileSize?: number;
  waveSpeed?: number;
  waveWidth?: number;
  glowColor?: [number, number, number];
  class?: string;
}

const {
  tileSize = 60,
  waveSpeed = 0.5,
  waveWidth = 0.15,
  glowColor = [0.88, 0.23, 0.07], // brand-red-orange in RGB (0-1)
  class: className = '',
} = Astro.props;
---

<canvas
  class:list={['tile-wave-canvas', className]}
  data-tile-size={tileSize}
  data-wave-speed={waveSpeed}
  data-wave-width={waveWidth}
  data-glow-color={JSON.stringify(glowColor)}
></canvas>

<style>
  .tile-wave-canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
</style>

<script>
  import * as THREE from 'three';

  const vertexShader = `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  const fragmentShader = `
    precision highp float;

    uniform float uTime;
    uniform vec2 uResolution;
    uniform vec2 uMouse;
    uniform float uTileSize;
    uniform float uWaveSpeed;
    uniform float uWaveWidth;
    uniform vec3 uGlowColor;
    uniform vec3 uBaseColor;
    uniform vec3 uLiftedColor;
    uniform vec3 uAccent1;
    uniform vec3 uAccent2;
    uniform vec3 uAccent3;

    varying vec2 vUv;

    // === NOISE FUNCTIONS ===
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

    float snoise(vec2 v) {
      const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                          -0.577350269189626, 0.024390243902439);
      vec2 i  = floor(v + dot(v, C.yy));
      vec2 x0 = v - i + dot(i, C.xx);
      vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
      vec4 x12 = x0.xyxy + C.xxzz;
      x12.xy -= i1;
      i = mod289(i);
      vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
      vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
      m = m*m; m = m*m;
      vec3 x = 2.0 * fract(p * C.www) - 1.0;
      vec3 h = abs(x) - 0.5;
      vec3 ox = floor(x + 0.5);
      vec3 a0 = x - ox;
      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
      vec3 g;
      g.x = a0.x * x0.x + h.x * x0.y;
      g.yz = a0.yz * x12.xz + h.yz * x12.yw;
      return 130.0 * dot(m, g);
    }

    void main() {
      vec2 pixel = vUv * uResolution;

      // === MOUSE WARP - apply before tile calculation ===
      vec2 toMouse = pixel - uMouse;
      float mouseDist = length(toMouse);
      float mouseRadius = 180.0;
      float mouseInfluence = smoothstep(mouseRadius, 0.0, mouseDist);

      // Push pixels away from mouse = tiles appear larger near cursor
      vec2 warpedPixel = pixel - toMouse * mouseInfluence * 0.3;

      vec2 tileCoord = floor(warpedPixel / uTileSize);
      vec2 tileCenter = (tileCoord + 0.5) * uTileSize;
      vec2 inTile = fract(warpedPixel / uTileSize);

      // Normalized position from center
      vec2 center = uResolution * 0.5;
      vec2 normPos = (tileCenter - center) / uResolution;
      float dist = length(normPos);

      // === ORGANIC CAUSTIC SHAPE ===
      // Animation time - uWaveSpeed controls overall pace
      float t = uTime * uWaveSpeed;

      // Multiple layers of noise for organic distortion
      float noise1 = snoise(normPos * 2.0 + t * 0.4) * 0.35;
      float noise2 = snoise(normPos * 4.0 - t * 0.25) * 0.18;
      float noise3 = snoise(normPos * 6.0 + t * 0.15) * 0.1;

      // Combine noise to distort the radial distance
      float distortion = noise1 + noise2 + noise3;
      float distortedDist = dist + distortion * 0.35;

      // Create organic blob shape - softer falloff
      float blobSize = 0.38 + sin(t * 0.8) * 0.06; // Breathing size
      float intensity = smoothstep(blobSize + 0.3, blobSize - 0.15, distortedDist);

      // Add caustic highlights - bright spots where noise peaks
      float caustics = snoise(normPos * 3.5 + t * 0.3);
      caustics = smoothstep(0.15, 0.75, caustics) * intensity * 0.5;

      // === THEME COLORS (from uniforms) ===
      // Color shifts based on noise - creates color variation in the blob
      float colorNoise = snoise(normPos * 2.5 + t * 0.2) * 0.5 + 0.5;
      vec3 warmGlow = mix(uAccent1, mix(uAccent2, uAccent3, colorNoise), colorNoise * 0.7);

      // Build final color
      vec3 tileColor = mix(uBaseColor, uLiftedColor, intensity * 0.7);

      // Add warm glow - more intense
      tileColor += warmGlow * intensity * 0.35;

      // Add caustic highlights - more prominent
      tileColor += warmGlow * caustics * 0.4;

      // === TILE BORDERS ===
      float borderWidth = 0.025;
      bool isBorder = inTile.x < borderWidth || inTile.x > 1.0 - borderWidth ||
                      inTile.y < borderWidth || inTile.y > 1.0 - borderWidth;

      if (isBorder) {
        float borderIntensity = intensity + caustics;
        tileColor *= mix(0.7, 1.2, borderIntensity);
        tileColor += warmGlow * borderIntensity * 0.08;
      }

      // === VIGNETTE ===
      float vignette = 1.0 - smoothstep(0.4, 1.2, dist);
      tileColor *= mix(0.4, 1.0, vignette);

      gl_FragColor = vec4(tileColor, 1.0);
    }
  `;

  function initTileWave(canvas: HTMLCanvasElement) {
    const tileSize = parseFloat(canvas.dataset.tileSize || '60');
    const waveSpeed = parseFloat(canvas.dataset.waveSpeed || '0.5');
    const waveWidth = parseFloat(canvas.dataset.waveWidth || '0.15');
    const glowColor = JSON.parse(canvas.dataset.glowColor || '[0.88, 0.23, 0.07]');

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: false,
      powerPreference: 'high-performance'
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Default theme colors (Bauhaus)
    const defaultColors = {
      base: [0.12, 0.08, 0.06],
      lifted: [0.22, 0.14, 0.10],
      accent1: [0.878, 0.231, 0.075],
      accent2: [0.988, 0.439, 0.165],
      accent3: [0.980, 0.655, 0.353]
    };

    // Shader material
    const uniforms = {
      uTime: { value: 0 },
      uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
      uMouse: { value: new THREE.Vector2(-1000, -1000) }, // Start offscreen
      uTileSize: { value: tileSize },
      uWaveSpeed: { value: waveSpeed },
      uWaveWidth: { value: waveWidth },
      uGlowColor: { value: new THREE.Vector3(...glowColor) },
      uBaseColor: { value: new THREE.Vector3(...defaultColors.base) },
      uLiftedColor: { value: new THREE.Vector3(...defaultColors.lifted) },
      uAccent1: { value: new THREE.Vector3(...defaultColors.accent1) },
      uAccent2: { value: new THREE.Vector3(...defaultColors.accent2) },
      uAccent3: { value: new THREE.Vector3(...defaultColors.accent3) }
    };

    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms
    });

    // Full-screen quad
    const geometry = new THREE.PlaneGeometry(2, 2);
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Animation loop
    let animationId: number;
    const clock = new THREE.Clock();

    function animate() {
      uniforms.uTime.value = clock.getElapsedTime();
      renderer.render(scene, camera);
      animationId = requestAnimationFrame(animate);
    }

    // Handle resize
    function onResize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
    }

    // Handle mouse movement
    function onMouseMove(e: MouseEvent) {
      uniforms.uMouse.value.set(e.clientX, window.innerHeight - e.clientY);
    }

    window.addEventListener('resize', onResize);

    // Track current tile size for mouse effect toggle
    let currentTileSize = tileSize;
    let mouseEnabled = tileSize >= 15;

    // Only enable mouse effect for larger tile sizes (performance optimization)
    if (mouseEnabled) {
      window.addEventListener('mousemove', onMouseMove);
    }

    // Listen for dynamic tile size changes
    function onTileSizeChange(e: CustomEvent<{ tileSize: number }>) {
      const newTileSize = e.detail.tileSize;
      uniforms.uTileSize.value = newTileSize;

      // Toggle mouse effect based on new tile size
      const shouldEnableMouse = newTileSize >= 15;
      if (shouldEnableMouse && !mouseEnabled) {
        window.addEventListener('mousemove', onMouseMove);
        mouseEnabled = true;
      } else if (!shouldEnableMouse && mouseEnabled) {
        window.removeEventListener('mousemove', onMouseMove);
        uniforms.uMouse.value.set(-1000, -1000); // Reset mouse position
        mouseEnabled = false;
      }
      currentTileSize = newTileSize;
    }

    // Listen for theme changes
    interface ThemeColors {
      base: [number, number, number];
      lifted: [number, number, number];
      accent1: [number, number, number];
      accent2: [number, number, number];
      accent3: [number, number, number];
    }

    function onThemeChange(e: CustomEvent<{ colors: ThemeColors }>) {
      const { colors } = e.detail;
      uniforms.uBaseColor.value.set(...colors.base);
      uniforms.uLiftedColor.value.set(...colors.lifted);
      uniforms.uAccent1.value.set(...colors.accent1);
      uniforms.uAccent2.value.set(...colors.accent2);
      uniforms.uAccent3.value.set(...colors.accent3);
    }

    window.addEventListener('tilewave:settilesize', onTileSizeChange as EventListener);
    window.addEventListener('tilewave:settheme', onThemeChange as EventListener);
    animate();

    // Cleanup on page navigation
    document.addEventListener('astro:before-swap', () => {
      cancelAnimationFrame(animationId);
      renderer.dispose();
      material.dispose();
      geometry.dispose();
      window.removeEventListener('resize', onResize);
      window.removeEventListener('tilewave:settilesize', onTileSizeChange as EventListener);
      window.removeEventListener('tilewave:settheme', onThemeChange as EventListener);
      if (mouseEnabled) {
        window.removeEventListener('mousemove', onMouseMove);
      }
    });
  }

  // Initialize when DOM is ready
  function init() {
    document.querySelectorAll('.tile-wave-canvas').forEach((canvas) => {
      initTileWave(canvas as HTMLCanvasElement);
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
